#include <iostream>
#include <vector>
#include <random>
#include <chrono>
#include <locale>

using namespace std;
using namespace std::chrono;

// Быстрая сортировка 
void quickSort(int* arr, int left, int right) {
    if (left >= right) return;

    int pivot = arr[left + (right - left) / 2];
    int i = left;
    int j = right;

    while (i <= j) {
        while (arr[i] < pivot) i++;
        while (arr[j] > pivot) j--;

        if (i <= j) {
            swap(arr[i], arr[j]);
            i++;
            j--;
        }
    }

    if (left < j) quickSort(arr, left, j);
    if (i < right) quickSort(arr, i, right);
}

// Сортировка слиянием
void mergeSort(int* arr, int left, int right, int* temp) {
    if (left >= right) return;

    int mid = left + (right - left) / 2;

    mergeSort(arr, left, mid, temp);
    mergeSort(arr, mid + 1, right, temp);

    // Слияние отсортированных частей
    int i = left;
    int j = mid + 1;
    int k = 0;

    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        }
        else {
            temp[k++] = arr[j++];
        }
    }

    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];

    // Копируем обратно в исходный массив
    for (i = left, k = 0; i <= right; i++, k++) {
        arr[i] = temp[k];
    }
}

// Проверка отсортированности массива
bool isSorted(const int* arr, int size) {
    for (int i = 1; i < size; i++) {
        if (arr[i] < arr[i - 1]) {
            return false;
        }
    }
    return true;
}

// Копирование массива
void copyArray(const int* source, int* destination, int size) {
    for (int i = 0; i < size; i++) {
        destination[i] = source[i];
    }
}

int main() {
    setlocale(LC_ALL, "Russian");

    // Все размеры массивов для тестирования
    vector<int> sizes = { 100, 500, 1000, 10000, 100000, 1000000, 10000000 };
    int numTests = 100; // количество прогонов для каждого размера массива

    // Проходим по всем размерам
    for (int size : sizes) {
        double totalQuick = 0, totalMerge = 0;
        bool allQuickSorted = true;
        bool allMergeSorted = true;

        // Подготовка генератора случайных чисел
        random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution<> dis(-100000, 100000);

        cout << "Размер массива: " << size << "\n";
        cout << "Количество тестов: " << numTests << "\n";

        // Тестирование
        for (int test = 0; test < numTests; test++) {
            // Выделение памяти для массивов
            int* original = new int[size];
            int* arrQuick = new int[size];
            int* arrMerge = new int[size];
            int* temp = new int[size]; // временный массив для mergeSort

            // Генерация случайного массива
            for (int i = 0; i < size; i++) {
                original[i] = dis(gen);
            }

            // Копирование для всех алгоритмов
            copyArray(original, arrQuick, size);
            copyArray(original, arrMerge, size);

            // 1. Быстрая сортировка
            auto start = high_resolution_clock::now();
            quickSort(arrQuick, 0, size - 1);
            auto end = high_resolution_clock::now();
            totalQuick += duration_cast<nanoseconds>(end - start).count() / 1000000.0;

            // Проверка сортировки
            if (!isSorted(arrQuick, size)) {
                allQuickSorted = false;
            }

            // 2. Сортировка слиянием
            start = high_resolution_clock::now();
            mergeSort(arrMerge, 0, size - 1, temp);
            end = high_resolution_clock::now();
            totalMerge += duration_cast<nanoseconds>(end - start).count() / 1000000.0;

            // Проверка сортировки
            if (!isSorted(arrMerge, size)) {
                allMergeSorted = false;
            }

            // Освобождение памяти
            delete[] original;
            delete[] arrQuick;
            delete[] arrMerge;
            delete[] temp;
        }

        // Результаты для этого размера
        double avgQuick = totalQuick / numTests;
        double avgMerge = totalMerge / numTests;

        // Вывод результатов
        cout << "Результаты:\n";
        cout << "  Быстрая сортировка:   " << avgQuick << " мс";
        cout << " [" << (allQuickSorted ? "OK" : "ERROR") << "]\n";
        cout << "  Сортировка слиянием:  " << avgMerge << " мс";
        cout << " [" << (allMergeSorted ? "OK" : "ERROR") << "]\n";
        cout << "  Отношение Quick/Merge:  " << (avgQuick / avgMerge) << "\n";
    }

    cout << "Все тесты завершены!\n";
    return 0;
}
